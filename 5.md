# API JWT認証機能設計書（簡易実装・Slim・単一ルート）

---

## 1. 概要

本設計書では、PHP 8.3 + Slim Framework において、追加のモジュールやクラスファイルを用いず、**最小限のコードで JWT 認証を実装**する方式を記述する。

対象 API は 1 つのみで、**JWT トークン内の `sub` が "abc" かつ `user` が "user0001" の場合のみアクセス可能**とする。

---

## 2. 対象 API

| 項目         | 内容                                                                 |
|--------------|----------------------------------------------------------------------|
| メソッド     | GET                                                                  |
| パス         | `/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool` |
| 利用者制限   | JWT における `sub == "abc"` かつ `user == "user0001"`               |
| 実装方法     | ルート内で直接 JWT 検証を行う（Slim のミドルウェア未使用）         |
| 認証方式     | Authorizationヘッダー + JWT（HS256）                                 |
| 使用ライブラリ | [firebase/php-jwt](https://github.com/firebase/php-jwt)（既存使用想定） |

---

## 3. JWT仕様

### 3.1 ヘッダー

```http
Authorization: Bearer <JWT文字列>

3.2 トークン例（payload）

{
  "user": "user0001",
  "sub": "abc",
  "exp": 1730000000
}


---

4. 実装方針

✅ ルート内で完結する認証ロジック

Slim の ->get() 定義内で JWT を直接解析・検証

トークンから sub と user を抽出し、一致する場合のみ処理を継続

エラー時は 401 または 403 を返却

複数のルートを保護しない前提で、ミドルウェア化は行わない



---

5. 実装コード（例）

use Slim\Factory\AppFactory;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;

require __DIR__ . '/../vendor/autoload.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$app = AppFactory::create();

$secret = 'your_jwt_secret'; // JWT署名用シークレット

$app->get('/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool',
    function (Request $request, Response $response) use ($secret) {

        $authHeader = $request->getHeaderLine('Authorization');
        if (!preg_match('/Bearer\s+(.*)$/i', $authHeader, $matches)) {
            return writeError($response, 401, 'JWTトークンが見つかりません');
        }

        $jwt = $matches[1];

        try {
            $decoded = JWT::decode($jwt, new Key($secret, 'HS256'));

            if (($decoded->user ?? '') !== 'user0001' || ($decoded->sub ?? '') !== 'abc') {
                return writeError($response, 403, '認可されていないユーザーです');
            }

            $response->getBody()->write(json_encode([
                'message' => '認証成功',
                'user' => $decoded->user,
                'cms' => $decoded->sub
            ]));
            return $response->withHeader('Content-Type', 'application/json');

        } catch (\Exception $e) {
            return writeError($response, 401, 'トークン検証失敗: ' . $e->getMessage());
        }
    }
);

// 共通エラーレスポンス出力
function writeError(Response $res, int $code, string $msg): Response {
    $res->getBody()->write(json_encode(['error' => $msg]));
    return $res->withStatus($code)->withHeader('Content-Type', 'application/json');
}

$app->run();


---

6. エラー応答仕様

ステータス	条件	例

200 OK	JWT 検証成功、かつユーザー一致	{"message": "認証成功", "user": ..., "cms": ...}
401	JWT 無効、署名不一致、期限切れ等	{"error": "JWTトークンが見つかりません"}
403	user/sub の内容が不一致	{"error": "認可されていないユーザーです"}



---

7. セキュリティ注意点

必ず HTTPS 上で通信すること（JWT 漏洩対策）

$secret は .env などで外部化推奨

JWT の exp は必須。長すぎない有効期限に設定すること

ユーザー追加やCMS増加が発生したら、認証条件を配列化する対応が必要



---

8. 今後の拡張可能性

拡張項目	方法案

ユーザー増加	$allowedUsers = ['user0001', 'user0002'] などで許可リスト化
CMS複数対応	$allowedCms = ['abc', 'def'] などで切り替え
ミドルウェア化	認証処理を独立した関数・クラスに移動して複数ルート共通化
ロール制御	JWTに role フィールドを追加して分岐



---

9. 補足：firebase/php-jwt の導入

composer require firebase/php-jwt

参考：https://github.com/firebase/php-jwt


---

10. 運用方針

ユーザー user0001 の JWT トークンは事前に発行済みとする（ログイン処理は本設計外）

現時点ではルート 1 本のみ保護対象。将来拡張時には共通化／分離設計を検討


---


# API JWT認証設計書（Slim4 + JWT、単一ルート簡易実装）

---

## 1. 概要

本設計書は、PHP 8.3 + Slim Framework 4.x を使用して、JWT 認証により**特定ユーザーのみが特定の API パスにアクセスできるようにする機能**を最小構成で実装する方針を示す。

認証対象は JWT トークンにより行い、トークン未所持または不正なユーザーのアクセスは拒否する。

---

## 2. フレームワーク・構成

| 項目             | 内容                                         |
|------------------|----------------------------------------------|
| PHP バージョン   | 8.3                                          |
| フレームワーク   | Slim Framework 4.x                           |
| 認証方式         | JWT（Authorizationヘッダー経由、HS256署名） |
| JWT ライブラリ   | firebase/php-jwt（Composer 管理）            |
| PHP拡張モジュール | ❌ 不要（純粋な PHP ライブラリのみ使用）      |

---

## 3. 認証ポリシー

- JWT トークン内の情報に基づいてアクセス制御を行う
- 以下の条件を全て満たす場合に限りリクエストを許可する：

  | クレーム | 条件値     |
  |----------|------------|
  | `user`   | `"user0001"` |
  | `sub`    | `"abc"`      |

- 条件を満たさない場合は HTTP ステータス `401`（認証失敗）または `403`（認可失敗）を返却する

---

## 4. 対象 API

| 項目     | 内容                                                                 |
|----------|----------------------------------------------------------------------|
| メソッド | GET                                                                  |
| パス     | `/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool` |
| 保護対象 | 上記パスは **JWT により認証された特定ユーザー（user0001）** のみアクセス可能 |
| 非認証ユーザー | ❌ アクセス拒否（401 または 403 を返却）                       |

---

## 5. JWT仕様

### 5.1 Authorization ヘッダー形式

Authorization: Bearer <JWTトークン>

### 5.2 JWT ペイロード（例）

```json
{
  "user": "user0001",
  "sub": "abc",
  "exp": 1730000000
}


---

6. 実装方針（最小構成）

認証処理はルート定義内に直接記述する（中間処理・クラスファイル追加なし）

Slim の ->get() 関数の中にて JWT トークン検証を行う

JWT が有効で、かつ user と sub が一致する場合のみ処理を実行

エラー時は共通関数にて JSON エラーメッセージを返却



---

7. 実装コード（例）

use Slim\Factory\AppFactory;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

require __DIR__ . '/../vendor/autoload.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$app = AppFactory::create();

$secret = 'your_jwt_secret';

$app->get('/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool', function (Request $request, Response $response) use ($secret) {

    $authHeader = $request->getHeaderLine('Authorization');
    if (!preg_match('/Bearer\s+(.*)$/i', $authHeader, $matches)) {
        return sendError($response, 401, 'トークンが見つかりません');
    }

    $jwt = $matches[1];

    try {
        $decoded = JWT::decode($jwt, new Key($secret, 'HS256'));

        if (($decoded->user ?? '') !== 'user0001' || ($decoded->sub ?? '') !== 'abc') {
            return sendError($response, 403, '許可されていないユーザーです');
        }

        $response->getBody()->write(json_encode([
            'message' => '認証成功',
            'user' => $decoded->user,
            'cms' => $decoded->sub
        ]));
        return $response->withHeader('Content-Type', 'application/json');

    } catch (Exception $e) {
        return sendError($response, 401, 'トークン無効: ' . $e->getMessage());
    }
});

function sendError(Response $res, int $code, string $msg): Response {
    $res->getBody()->write(json_encode(['error' => $msg]));
    return $res->withStatus($code)->withHeader('Content-Type', 'application/json');
}

$app->run();


---

8. エラーレスポンス仕様

ステータス	説明	内容例

200 OK	認証成功	{ "message": "認証成功", "user": ..., "cms": ... }
401	JWTなし/無効/期限切れ	{ "error": "トークンが見つかりません" } または署名エラー
403	user または sub 不一致	{ "error": "許可されていないユーザーです" }



---

9. 使用ライブラリ

composer require firebase/php-jwt

GitHub: https://github.com/firebase/php-jwt

外部 PHP モジュールは不要（ext-* 依存なし）



---

10. 注意点と補足

本設計はあくまで「特定の API パスを特定の JWT ユーザーに制限する」簡易設計である

ユーザーやパスが増える場合は、共通関数化またはミドルウェア化を検討

シークレットキーは config や .env に外部化推奨

通信は必ず HTTPS 上で行うこと


# API トークン認証設計書（Slim4・Authorizationヘッダー・最小構成）

---

## 1. 概要

本設計書は、PHP 8.3 + Slim Framework 4.x を用いて、外部ライブラリやJWT構文を使用せず、HTTPヘッダー `Authorization` に含まれる**特定のトークン文字列**のみを利用した簡易認証を実装する。

当該 API には特定のトークンを所持するユーザー（`user0001`）のみアクセス可能とし、それ以外のアクセスは拒否する。

---

## 2. 対象環境・構成

| 項目             | 内容                                          |
|------------------|-----------------------------------------------|
| PHP バージョン   | 8.3                                           |
| フレームワーク   | Slim Framework 4.x                            |
| 認証方式         | Authorizationヘッダーによる固定トークン検証   |
| JWT構文/署名     | ❌ 不使用（`firebase/php-jwt` 等のライブラリ不要） |
| PHPモジュール追加 | ❌ 不要（純粋な文字列比較のみ）                 |

---

## 3. 認証ポリシー

以下の条件をすべて満たす場合にのみアクセスを許可する：

- HTTPヘッダー `Authorization` に以下の完全一致トークンが含まれていること

```http
Authorization: Bearer user0001-abc-secure-token

上記以外のトークン値、またはヘッダー未指定の場合は 401 Unauthorized を返却



---

4. 対象 API

項目	内容

メソッド	GET
パス	/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool
保護対象	上記パスは事前に発行されたトークンを持つユーザーのみアクセス可能
対象ユーザー	user0001（トークンは手動配布）
トークン例	Bearer user0001-abc-secure-token



---

5. 実装方針

認証処理は Slim のルート内に直接記述

Authorization ヘッダーの文字列をそのまま比較

トークン一致時のみリクエストを処理

不一致・未設定時は共通の JSON エラーを返却



---

6. 実装コード（例）

use Slim\Factory\AppFactory;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

require __DIR__ . '/../vendor/autoload.php';

$app = AppFactory::create();

// 許可されたトークン（固定値）
$validToken = 'Bearer user0001-abc-secure-token';

$app->get('/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool', function (Request $request, Response $response) use ($validToken) {
    
    $authHeader = $request->getHeaderLine('Authorization');

    if ($authHeader !== $validToken) {
        $response->getBody()->write(json_encode([
            'error' => 'Unauthorized'
        ]));
        return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
    }

    // 認証成功時のレスポンス
    $response->getBody()->write(json_encode([
        'message' => '認証成功：user0001 のみアクセス可能'
    ]));
    return $response->withHeader('Content-Type', 'application/json');
});

$app->run();


---

7. エラーレスポンス仕様

ステータス	条件	内容例

200 OK	トークン一致（認証成功）	{ "message": "認証成功：user0001 のみアクセス可能" }
401	トークンなし／不一致／改ざん	{ "error": "Unauthorized" }



---

8. セキュリティ上の注意点

項目	内容

HTTPS 必須	通信中のトークン漏洩防止のため、HTTPS環境のみ使用可能
トークンの秘匿	トークン値はログ・URL・画面等に出力しないこと
トークンの再発行	トークンが漏洩した場合は早急に無効化・変更すること
トークン管理	.env ファイルやセキュアな設定ファイルで管理推奨
有効期限	本方式ではトークンに有効期限がないため、定期的な更新を検討



---


# 共通実行制御（exec）への簡易認証機能追加 仕様書

---

## 1. 背景・目的

本仕様書は、既存のPHPアプリケーションにおける共通実行制御モジュール（以下、「exec」と記載）に対し、特定APIパスを保護するための簡易認証機能を追加するための設計指針を定める。

対象となるAPI `/cms/site/abc/package/tool` は、本来特定のユーザーのみが操作可能であるべき機能であるが、現状は認証保護されていない。そこで、最小限の実装負荷かつ既存機能に影響を与えない形で、静的トークンによる認証制御を共通処理に追加する。

---

## 2. 対象システム・構成

| 項目             | 内容                                       |
|------------------|--------------------------------------------|
| 実行環境         | PHP 8.3                                    |
| フレームワーク   | Slim Framework 4.x                         |
| 認証対象パス     | `/cms/site/abc/package/tool`               |
| 対象ユーザー     | `user0001`                                 |
| 実装対象ファイル | 共通実行モジュール `exec.php`             |
| HTTP種別         | HTTP API（Authorizationヘッダー使用）     |

---

## 3. 認証方式

### 3.1 認証方法の概要

- HTTP リクエストヘッダー `Authorization` に付与された固定トークンを検証
- 指定されたパス（`/cms/site/abc/package/tool`）に対してのみ適用
- トークン不一致時は `401 Unauthorized` を返却し処理を中断
- トークン一致時は既存処理をそのまま継続実行

### 3.2 トークン仕様

| 項目        | 内容                              |
|-------------|-----------------------------------|
| トークン形式 | `Bearer user0001-abc-secure-token` |
| 検証方法    | 文字列一致による比較               |
| 保管場所    | PHPコード内に直接定義（簡易実装）  |
| 暗号化      | なし（平文でのヘッダー比較）       |

---

## 4. 実装方針

### 4.1 実装場所

以下のファイルの冒頭（任意の処理前）に挿入する：

/home/dev-test/private/slim4_abc_merge/exec.php

### 4.2 処理フロー概要

1. `$_SERVER['REQUEST_URI']` で現在のリクエストパスを取得
2. 対象パスに該当するかを `strpos()` で判定
3. `$_SERVER['HTTP_AUTHORIZATION']` よりトークンを取得
4. 許可トークンと一致しない場合、401 エラーを返却して `exit`
5. 一致する場合、既存の処理へ遷移

### 4.3 実装コード

```php
<?php
// 認証制御処理（exec.phpの先頭に追加）

$requestUri = $_SERVER['REQUEST_URI'] ?? '';
$authHeader = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
$validToken = 'Bearer user0001-abc-secure-token';

$isProtectedPath = strpos($requestUri, '/cms/site/abc/package/tool') !== false;

if ($isProtectedPath && $authHeader !== $validToken) {
    http_response_code(401);
    header('Content-Type: application/json');
    echo json_encode(['error' => 'Unauthorized']);
    exit;
}

※ Apacheやnginx構成によっては $_SERVER['REDIRECT_HTTP_AUTHORIZATION'] を使用する必要あり。


---

5. エラーハンドリング

条件	HTTPステータス	レスポンス内容

認証成功	200	通常の処理結果（既存ロジック通り）
認証失敗（トークン不一致）	401	{ "error": "Unauthorized" }（JSON形式）
Authorizationヘッダーなし	401	同上



---

6. 非影響範囲

以下の条件では本認証ロジックはスキップされ、既存機能に一切の影響を与えない：

REQUEST_URI が /cms/site/abc/package/tool に該当しない場合

トークンが一致している場合

Slimルーティングとは無関係な CLI 実行や別用途の exec 呼び出し時



---

7. 保守性・拡張性

項目	将来的な対応

トークンの管理	.env ファイルや外部設定ファイルに切り出し可能
対象パスの追加	$isProtectedPath に OR 条件で複数パスを追加
複数ユーザー対応	$validToken を配列にして in_array() で検証
JWT化対応	ライブラリ導入により将来的に段階的に強化可能
ログ出力	不正アクセスのログ出力（logファイルや監査対応）可



---

8. セキュリティ上の注意事項

トークンは簡易的な静的文字列比較のため、運用上の厳重な管理が必要

HTTPS 経由での通信を前提とし、通信路の盗聴リスクを回避

トークンの漏洩が発生した場合、即時トークン変更・再デプロイが必要

外部公開APIへの展開には向かず、内部限定運用が前提



---

9. テスト項目

テストケース	期待結果

正常：正しいトークンでアクセス	200レスポンス（API正常動作）
異常：トークンが不一致	401 Unauthorized エラー
異常：Authorizationヘッダーなし	同上
異常：対象外パスへアクセス	認証処理スキップ、通常通り動作



---

10. 実装・レビュー履歴

日付	内容	担当

2025-07-15	初版作成・設計	PG（あなた）
YYYY-MM-DD	実装・レビュー完了	（レビュワー）

