# API JWT認証機能設計書（簡易実装・Slim・単一ルート）

---

## 1. 概要

本設計書では、PHP 8.3 + Slim Framework において、追加のモジュールやクラスファイルを用いず、**最小限のコードで JWT 認証を実装**する方式を記述する。

対象 API は 1 つのみで、**JWT トークン内の `sub` が "abc" かつ `user` が "user0001" の場合のみアクセス可能**とする。

---

## 2. 対象 API

| 項目         | 内容                                                                 |
|--------------|----------------------------------------------------------------------|
| メソッド     | GET                                                                  |
| パス         | `/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool` |
| 利用者制限   | JWT における `sub == "abc"` かつ `user == "user0001"`               |
| 実装方法     | ルート内で直接 JWT 検証を行う（Slim のミドルウェア未使用）         |
| 認証方式     | Authorizationヘッダー + JWT（HS256）                                 |
| 使用ライブラリ | [firebase/php-jwt](https://github.com/firebase/php-jwt)（既存使用想定） |

---

## 3. JWT仕様

### 3.1 ヘッダー

```http
Authorization: Bearer <JWT文字列>

3.2 トークン例（payload）

{
  "user": "user0001",
  "sub": "abc",
  "exp": 1730000000
}


---

4. 実装方針

✅ ルート内で完結する認証ロジック

Slim の ->get() 定義内で JWT を直接解析・検証

トークンから sub と user を抽出し、一致する場合のみ処理を継続

エラー時は 401 または 403 を返却

複数のルートを保護しない前提で、ミドルウェア化は行わない



---

5. 実装コード（例）

use Slim\Factory\AppFactory;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;

require __DIR__ . '/../vendor/autoload.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$app = AppFactory::create();

$secret = 'your_jwt_secret'; // JWT署名用シークレット

$app->get('/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool',
    function (Request $request, Response $response) use ($secret) {

        $authHeader = $request->getHeaderLine('Authorization');
        if (!preg_match('/Bearer\s+(.*)$/i', $authHeader, $matches)) {
            return writeError($response, 401, 'JWTトークンが見つかりません');
        }

        $jwt = $matches[1];

        try {
            $decoded = JWT::decode($jwt, new Key($secret, 'HS256'));

            if (($decoded->user ?? '') !== 'user0001' || ($decoded->sub ?? '') !== 'abc') {
                return writeError($response, 403, '認可されていないユーザーです');
            }

            $response->getBody()->write(json_encode([
                'message' => '認証成功',
                'user' => $decoded->user,
                'cms' => $decoded->sub
            ]));
            return $response->withHeader('Content-Type', 'application/json');

        } catch (\Exception $e) {
            return writeError($response, 401, 'トークン検証失敗: ' . $e->getMessage());
        }
    }
);

// 共通エラーレスポンス出力
function writeError(Response $res, int $code, string $msg): Response {
    $res->getBody()->write(json_encode(['error' => $msg]));
    return $res->withStatus($code)->withHeader('Content-Type', 'application/json');
}

$app->run();


---

6. エラー応答仕様

ステータス	条件	例

200 OK	JWT 検証成功、かつユーザー一致	{"message": "認証成功", "user": ..., "cms": ...}
401	JWT 無効、署名不一致、期限切れ等	{"error": "JWTトークンが見つかりません"}
403	user/sub の内容が不一致	{"error": "認可されていないユーザーです"}



---

7. セキュリティ注意点

必ず HTTPS 上で通信すること（JWT 漏洩対策）

$secret は .env などで外部化推奨

JWT の exp は必須。長すぎない有効期限に設定すること

ユーザー追加やCMS増加が発生したら、認証条件を配列化する対応が必要



---

8. 今後の拡張可能性

拡張項目	方法案

ユーザー増加	$allowedUsers = ['user0001', 'user0002'] などで許可リスト化
CMS複数対応	$allowedCms = ['abc', 'def'] などで切り替え
ミドルウェア化	認証処理を独立した関数・クラスに移動して複数ルート共通化
ロール制御	JWTに role フィールドを追加して分岐



---

9. 補足：firebase/php-jwt の導入

composer require firebase/php-jwt

参考：https://github.com/firebase/php-jwt


---

10. 運用方針

ユーザー user0001 の JWT トークンは事前に発行済みとする（ログイン処理は本設計外）

現時点ではルート 1 本のみ保護対象。将来拡張時には共通化／分離設計を検討


---


# API JWT認証設計書（Slim4 + JWT、単一ルート簡易実装）

---

## 1. 概要

本設計書は、PHP 8.3 + Slim Framework 4.x を使用して、JWT 認証により**特定ユーザーのみが特定の API パスにアクセスできるようにする機能**を最小構成で実装する方針を示す。

認証対象は JWT トークンにより行い、トークン未所持または不正なユーザーのアクセスは拒否する。

---

## 2. フレームワーク・構成

| 項目             | 内容                                         |
|------------------|----------------------------------------------|
| PHP バージョン   | 8.3                                          |
| フレームワーク   | Slim Framework 4.x                           |
| 認証方式         | JWT（Authorizationヘッダー経由、HS256署名） |
| JWT ライブラリ   | firebase/php-jwt（Composer 管理）            |
| PHP拡張モジュール | ❌ 不要（純粋な PHP ライブラリのみ使用）      |

---

## 3. 認証ポリシー

- JWT トークン内の情報に基づいてアクセス制御を行う
- 以下の条件を全て満たす場合に限りリクエストを許可する：

  | クレーム | 条件値     |
  |----------|------------|
  | `user`   | `"user0001"` |
  | `sub`    | `"abc"`      |

- 条件を満たさない場合は HTTP ステータス `401`（認証失敗）または `403`（認可失敗）を返却する

---

## 4. 対象 API

| 項目     | 内容                                                                 |
|----------|----------------------------------------------------------------------|
| メソッド | GET                                                                  |
| パス     | `/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool` |
| 保護対象 | 上記パスは **JWT により認証された特定ユーザー（user0001）** のみアクセス可能 |
| 非認証ユーザー | ❌ アクセス拒否（401 または 403 を返却）                       |

---

## 5. JWT仕様

### 5.1 Authorization ヘッダー形式

Authorization: Bearer <JWTトークン>

### 5.2 JWT ペイロード（例）

```json
{
  "user": "user0001",
  "sub": "abc",
  "exp": 1730000000
}


---

6. 実装方針（最小構成）

認証処理はルート定義内に直接記述する（中間処理・クラスファイル追加なし）

Slim の ->get() 関数の中にて JWT トークン検証を行う

JWT が有効で、かつ user と sub が一致する場合のみ処理を実行

エラー時は共通関数にて JSON エラーメッセージを返却



---

7. 実装コード（例）

use Slim\Factory\AppFactory;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

require __DIR__ . '/../vendor/autoload.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$app = AppFactory::create();

$secret = 'your_jwt_secret';

$app->get('/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool', function (Request $request, Response $response) use ($secret) {

    $authHeader = $request->getHeaderLine('Authorization');
    if (!preg_match('/Bearer\s+(.*)$/i', $authHeader, $matches)) {
        return sendError($response, 401, 'トークンが見つかりません');
    }

    $jwt = $matches[1];

    try {
        $decoded = JWT::decode($jwt, new Key($secret, 'HS256'));

        if (($decoded->user ?? '') !== 'user0001' || ($decoded->sub ?? '') !== 'abc') {
            return sendError($response, 403, '許可されていないユーザーです');
        }

        $response->getBody()->write(json_encode([
            'message' => '認証成功',
            'user' => $decoded->user,
            'cms' => $decoded->sub
        ]));
        return $response->withHeader('Content-Type', 'application/json');

    } catch (Exception $e) {
        return sendError($response, 401, 'トークン無効: ' . $e->getMessage());
    }
});

function sendError(Response $res, int $code, string $msg): Response {
    $res->getBody()->write(json_encode(['error' => $msg]));
    return $res->withStatus($code)->withHeader('Content-Type', 'application/json');
}

$app->run();


---

8. エラーレスポンス仕様

ステータス	説明	内容例

200 OK	認証成功	{ "message": "認証成功", "user": ..., "cms": ... }
401	JWTなし/無効/期限切れ	{ "error": "トークンが見つかりません" } または署名エラー
403	user または sub 不一致	{ "error": "許可されていないユーザーです" }



---

9. 使用ライブラリ

composer require firebase/php-jwt

GitHub: https://github.com/firebase/php-jwt

外部 PHP モジュールは不要（ext-* 依存なし）



---

10. 注意点と補足

本設計はあくまで「特定の API パスを特定の JWT ユーザーに制限する」簡易設計である

ユーザーやパスが増える場合は、共通関数化またはミドルウェア化を検討

シークレットキーは config や .env に外部化推奨

通信は必ず HTTPS 上で行うこと


# API トークン認証設計書（Slim4・Authorizationヘッダー・最小構成）

---

## 1. 概要

本設計書は、PHP 8.3 + Slim Framework 4.x を用いて、外部ライブラリやJWT構文を使用せず、HTTPヘッダー `Authorization` に含まれる**特定のトークン文字列**のみを利用した簡易認証を実装する。

当該 API には特定のトークンを所持するユーザー（`user0001`）のみアクセス可能とし、それ以外のアクセスは拒否する。

---

## 2. 対象環境・構成

| 項目             | 内容                                          |
|------------------|-----------------------------------------------|
| PHP バージョン   | 8.3                                           |
| フレームワーク   | Slim Framework 4.x                            |
| 認証方式         | Authorizationヘッダーによる固定トークン検証   |
| JWT構文/署名     | ❌ 不使用（`firebase/php-jwt` 等のライブラリ不要） |
| PHPモジュール追加 | ❌ 不要（純粋な文字列比較のみ）                 |

---

## 3. 認証ポリシー

以下の条件をすべて満たす場合にのみアクセスを許可する：

- HTTPヘッダー `Authorization` に以下の完全一致トークンが含まれていること

```http
Authorization: Bearer user0001-abc-secure-token

上記以外のトークン値、またはヘッダー未指定の場合は 401 Unauthorized を返却



---

4. 対象 API

項目	内容

メソッド	GET
パス	/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool
保護対象	上記パスは事前に発行されたトークンを持つユーザーのみアクセス可能
対象ユーザー	user0001（トークンは手動配布）
トークン例	Bearer user0001-abc-secure-token



---

5. 実装方針

認証処理は Slim のルート内に直接記述

Authorization ヘッダーの文字列をそのまま比較

トークン一致時のみリクエストを処理

不一致・未設定時は共通の JSON エラーを返却



---

6. 実装コード（例）

use Slim\Factory\AppFactory;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

require __DIR__ . '/../vendor/autoload.php';

$app = AppFactory::create();

// 許可されたトークン（固定値）
$validToken = 'Bearer user0001-abc-secure-token';

$app->get('/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool', function (Request $request, Response $response) use ($validToken) {
    
    $authHeader = $request->getHeaderLine('Authorization');

    if ($authHeader !== $validToken) {
        $response->getBody()->write(json_encode([
            'error' => 'Unauthorized'
        ]));
        return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
    }

    // 認証成功時のレスポンス
    $response->getBody()->write(json_encode([
        'message' => '認証成功：user0001 のみアクセス可能'
    ]));
    return $response->withHeader('Content-Type', 'application/json');
});

$app->run();


---

7. エラーレスポンス仕様

ステータス	条件	内容例

200 OK	トークン一致（認証成功）	{ "message": "認証成功：user0001 のみアクセス可能" }
401	トークンなし／不一致／改ざん	{ "error": "Unauthorized" }



---

8. セキュリティ上の注意点

項目	内容

HTTPS 必須	通信中のトークン漏洩防止のため、HTTPS環境のみ使用可能
トークンの秘匿	トークン値はログ・URL・画面等に出力しないこと
トークンの再発行	トークンが漏洩した場合は早急に無効化・変更すること
トークン管理	.env ファイルやセキュアな設定ファイルで管理推奨
有効期限	本方式ではトークンに有効期限がないため、定期的な更新を検討



---
