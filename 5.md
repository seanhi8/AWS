# API JWT認証機能設計書（簡易実装・Slim・単一ルート）

---

## 1. 概要

本設計書では、PHP 8.3 + Slim Framework において、追加のモジュールやクラスファイルを用いず、**最小限のコードで JWT 認証を実装**する方式を記述する。

対象 API は 1 つのみで、**JWT トークン内の `sub` が "abc" かつ `user` が "user0001" の場合のみアクセス可能**とする。

---

## 2. 対象 API

| 項目         | 内容                                                                 |
|--------------|----------------------------------------------------------------------|
| メソッド     | GET                                                                  |
| パス         | `/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool` |
| 利用者制限   | JWT における `sub == "abc"` かつ `user == "user0001"`               |
| 実装方法     | ルート内で直接 JWT 検証を行う（Slim のミドルウェア未使用）         |
| 認証方式     | Authorizationヘッダー + JWT（HS256）                                 |
| 使用ライブラリ | [firebase/php-jwt](https://github.com/firebase/php-jwt)（既存使用想定） |

---

## 3. JWT仕様

### 3.1 ヘッダー

```http
Authorization: Bearer <JWT文字列>

3.2 トークン例（payload）

{
  "user": "user0001",
  "sub": "abc",
  "exp": 1730000000
}


---

4. 実装方針

✅ ルート内で完結する認証ロジック

Slim の ->get() 定義内で JWT を直接解析・検証

トークンから sub と user を抽出し、一致する場合のみ処理を継続

エラー時は 401 または 403 を返却

複数のルートを保護しない前提で、ミドルウェア化は行わない



---

5. 実装コード（例）

use Slim\Factory\AppFactory;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;

require __DIR__ . '/../vendor/autoload.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$app = AppFactory::create();

$secret = 'your_jwt_secret'; // JWT署名用シークレット

$app->get('/home/dev-test/private/slim4_abc_merge/cms/site/abc/package/tool',
    function (Request $request, Response $response) use ($secret) {

        $authHeader = $request->getHeaderLine('Authorization');
        if (!preg_match('/Bearer\s+(.*)$/i', $authHeader, $matches)) {
            return writeError($response, 401, 'JWTトークンが見つかりません');
        }

        $jwt = $matches[1];

        try {
            $decoded = JWT::decode($jwt, new Key($secret, 'HS256'));

            if (($decoded->user ?? '') !== 'user0001' || ($decoded->sub ?? '') !== 'abc') {
                return writeError($response, 403, '認可されていないユーザーです');
            }

            $response->getBody()->write(json_encode([
                'message' => '認証成功',
                'user' => $decoded->user,
                'cms' => $decoded->sub
            ]));
            return $response->withHeader('Content-Type', 'application/json');

        } catch (\Exception $e) {
            return writeError($response, 401, 'トークン検証失敗: ' . $e->getMessage());
        }
    }
);

// 共通エラーレスポンス出力
function writeError(Response $res, int $code, string $msg): Response {
    $res->getBody()->write(json_encode(['error' => $msg]));
    return $res->withStatus($code)->withHeader('Content-Type', 'application/json');
}

$app->run();


---

6. エラー応答仕様

ステータス	条件	例

200 OK	JWT 検証成功、かつユーザー一致	{"message": "認証成功", "user": ..., "cms": ...}
401	JWT 無効、署名不一致、期限切れ等	{"error": "JWTトークンが見つかりません"}
403	user/sub の内容が不一致	{"error": "認可されていないユーザーです"}



---

7. セキュリティ注意点

必ず HTTPS 上で通信すること（JWT 漏洩対策）

$secret は .env などで外部化推奨

JWT の exp は必須。長すぎない有効期限に設定すること

ユーザー追加やCMS増加が発生したら、認証条件を配列化する対応が必要



---

8. 今後の拡張可能性

拡張項目	方法案

ユーザー増加	$allowedUsers = ['user0001', 'user0002'] などで許可リスト化
CMS複数対応	$allowedCms = ['abc', 'def'] などで切り替え
ミドルウェア化	認証処理を独立した関数・クラスに移動して複数ルート共通化
ロール制御	JWTに role フィールドを追加して分岐



---

9. 補足：firebase/php-jwt の導入

composer require firebase/php-jwt

参考：https://github.com/firebase/php-jwt


---

10. 運用方針

ユーザー user0001 の JWT トークンは事前に発行済みとする（ログイン処理は本設計外）

現時点ではルート 1 本のみ保護対象。将来拡張時には共通化／分離設計を検討


---
