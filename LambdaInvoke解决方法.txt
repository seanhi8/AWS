ğŸ§± AWS CDK ä¸­æ­£ç¡®ä½¿ç”¨ LambdaInvoke çš„å®Œæ•´ç¤ºä¾‹ä¸è®²è§£ï¼ˆTypeScriptï¼‰
ğŸ“Œ ç›®æ ‡
æˆ‘ä»¬ä½¿ç”¨ 4 ä¸ª Lambda å‡½æ•°æ¥æ„å»ºå¤šä¸ª Step Function çŠ¶æ€æœºï¼Œæ¯ä¸ªçŠ¶æ€æœºä¸²è”è°ƒç”¨è¿™äº› Lambda å‡½æ•°ï¼Œä½†é¡ºåºä¸åŒã€‚å¹¶é€šè¿‡å°è£…å‡½æ•°ç®€åŒ–ä»£ç ç»“æ„ï¼Œé¿å… LambdaInvoke é‡å¤ä½¿ç”¨æŠ¥é”™çš„é—®é¢˜ã€‚

ğŸ§  å…³é”®åŸåˆ™
ç±»å‹	å¯å¦å¤ç”¨	è¯´æ˜
lambda.Function	âœ… å¯å¤ç”¨	ä¸€ä¸ª Lambda å‡½æ•°å¯ç”¨äºå¤šä¸ªçŠ¶æ€æœº
LambdaInvoke	âŒ ä¸å¯å¤ç”¨	æ¯æ¬¡ç”¨å¿…é¡» new ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œä¸èƒ½è¢«å¤šä¸ªé“¾å¤ç”¨

ğŸ“¦ å®‰è£…ä¾èµ–ï¼ˆå¦‚å°šæœªåˆå§‹åŒ– CDKï¼‰
npx cdk init app --language=typescript
npm install aws-cdk-lib constructs

âœ… å®Œæ•´ç¤ºä¾‹ä»£ç ï¼ˆå«ä¸­æ–‡æ³¨é‡Šï¼‰
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as sfn from 'aws-cdk-lib/aws-stepfunctions';
import * as tasks from 'aws-cdk-lib/aws-stepfunctions-tasks';

export class StepFunctionChainStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // âœ… åˆ›å»º 4 ä¸ªå¯å¤ç”¨çš„ Lambda å‡½æ•°
    const lambdaFn1 = this.createLambda('LambdaFn1');
    const lambdaFn2 = this.createLambda('LambdaFn2');
    const lambdaFn3 = this.createLambda('LambdaFn3');
    const lambdaFn4 = this.createLambda('LambdaFn4');

    // âœ… çŠ¶æ€æœº 1ï¼š1 â†’ 2 â†’ 3 â†’ 4
    const sm1 = this.createLambdaChain('SM1', [lambdaFn1, lambdaFn2, lambdaFn3, lambdaFn4]);
    new sfn.StateMachine(this, 'StateMachineSM1', {
      definition: sm1,
      stateMachineType: sfn.StateMachineType.STANDARD,
    });

    // âœ… çŠ¶æ€æœº 2ï¼š2 â†’ 1 â†’ 3 â†’ 4
    const sm2 = this.createLambdaChain('SM2', [lambdaFn2, lambdaFn1, lambdaFn3, lambdaFn4]);
    new sfn.StateMachine(this, 'StateMachineSM2', {
      definition: sm2,
      stateMachineType: sfn.StateMachineType.STANDARD,
    });

    // âœ… çŠ¶æ€æœº 3ï¼š3 â†’ 2 â†’ 1 â†’ 4
    const sm3 = this.createLambdaChain('SM3', [lambdaFn3, lambdaFn2, lambdaFn1, lambdaFn4]);
    new sfn.StateMachine(this, 'StateMachineSM3', {
      definition: sm3,
      stateMachineType: sfn.StateMachineType.STANDARD,
    });
  }

  /**
   * âœ… ç®€åŒ–åˆ›å»º Lambda çš„å·¥å…·å‡½æ•°
   */
  private createLambda(id: string): lambda.Function {
    return new lambda.Function(this, id, {
      runtime: lambda.Runtime.NODEJS_18_X,
      handler: 'index.handler',
      code: lambda.Code.fromInline(`
        exports.handler = async (event) => {
          console.log("Hello from ${id}", event);
          return { result: "${id} finished" };
        };
      `),
    });
  }

  /**
   * âœ… æ„é€  LambdaInvoke çš„é“¾å¼è°ƒç”¨ï¼ˆæ¯æ¬¡éƒ½ new æ–°çš„ LambdaInvoke å®ä¾‹ï¼‰
   */
  private createLambdaChain(prefix: string, fns: lambda.IFunction[]): sfn.Chain {
    const steps = fns.map((fn, index) => {
      return new tasks.LambdaInvoke(this, `${prefix}_Lambda${index + 1}`, {
        lambdaFunction: fn,                // âœ… ç»‘å®š Lambda å‡½æ•°
        payloadResponseOnly: true,         // âœ… ä»…è¿”å› Payloadï¼Œä¸å«å®Œæ•´å“åº”ç»“æ„
      });
    });

    const [first, ...rest] = steps;
    return rest.reduce((chain, step) => chain.next(step), first);
  }
}

âš ï¸ å¸¸è§é”™è¯¯ä¸æ³¨æ„äº‹é¡¹
âŒ é”™è¯¯ç¤ºä¾‹ï¼ˆä¼šæŠ¥é”™ï¼‰
const step1 = new LambdaInvoke(...);
const sm1 = step1.next(...); // âœ… ä½¿ç”¨äº†ä¸€æ¬¡
const sm2 = step1.next(...); // âŒ å†æ¬¡ä½¿ç”¨åŒä¸€ä¸ªå¯¹è±¡ï¼ŒæŠ¥é”™ï¼
é”™è¯¯æç¤ºï¼š
StateMachine already contains state 'SM1_Lambda1'
OR
State is already used in another chain

ğŸ›  æ‰‹åŠ¨åˆ›å»º LambdaInvoke çš„æ–¹å¼ï¼ˆå¯¹æ¯”å°è£…ï¼‰
const step1 = new tasks.LambdaInvoke(this, 'SM1_Lambda1', {
  lambdaFunction: lambdaFn1,
  payloadResponseOnly: true,
});

const step2 = new tasks.LambdaInvoke(this, 'SM1_Lambda2', {
  lambdaFunction: lambdaFn2,
  payloadResponseOnly: true,
});

const sm1 = step1.next(step2);

ğŸ“Œ æ€»ç»“
âœ… æ¯ä¸ª Lambda å‡½æ•°å¯ä»¥é‡å¤ä½¿ç”¨
âŒ æ¯ä¸ª LambdaInvoke å¿…é¡»æ˜¯å…¨æ–°çš„å®ä¾‹
âœ… å°è£… createLambdaChain() å¯ä»¥ç®€åŒ– .next().next() å†™æ³•
âœ… ä½¿ç”¨ payloadResponseOnly: true å¯ä»¥è®©è¾“å‡ºæ›´æ¸…çˆ½

----------------------------------------------------------------------------

LambdaInvoke æ˜¯åœ¨ createLambdaChain() è¿™ä¸ªå‡½æ•°é‡Œåˆ›å»ºçš„

private createLambdaChain(prefix: string, fns: lambda.IFunction[]): sfn.Chain {
  const steps = fns.map((fn, index) => {
    return new tasks.LambdaInvoke(this, `${prefix}_Lambda${index + 1}`, {
      lambdaFunction: fn,                // âœ… è®¾ç½®è°ƒç”¨å“ªä¸ª Lambda å‡½æ•°
      payloadResponseOnly: true,         // âœ… ç­‰ä»·äº outputPath: '$.Payload'
    });
  });

  const [first, ...rest] = steps;
  return rest.reduce((chain, step) => chain.next(step), first);
}


LambdaInvoke çš„è®¾å®šè¯´æ˜ï¼ˆä¸­æ–‡è¯¦è§£ï¼‰
new tasks.LambdaInvoke(...) æ„é€ å‡½æ•°ä¼ å…¥äº†è¿™äº›å…³é”®å‚æ•°ï¼š
| å‚æ•°                             | ç¤ºä¾‹                            | è¯´æ˜                                                    |
| ------------------------------ | ----------------------------- | ----------------------------------------------------- |
| `this`                         | å½“å‰ Construct                  | è¡¨ç¤º CDK æ ‘ä¸­çš„ä½œç”¨åŸŸ                                         |
| `${prefix}_Lambda${index + 1}` | æ¯”å¦‚ `SM1_Lambda1`              | æ¯ä¸ªçŠ¶æ€çš„å”¯ä¸€ IDï¼Œé˜²æ­¢å†²çª                                       |
| `lambdaFunction: fn`           | æ¯”å¦‚ `lambdaFn1`                | æŒ‡å®šè¦è°ƒç”¨çš„ Lambda å‡½æ•°                                      |
| `payloadResponseOnly: true`    | ç›¸å½“äº `outputPath: "$.Payload"` | åªè¿”å› `Lambda` çš„è¿”å›å€¼ä¸­çš„ Payload éƒ¨åˆ†ï¼Œç®€åŒ– Step Function çš„è¾“å‡ºç»“æ„ |

æ›¿ä»£å†™æ³•ï¼ˆå®Œå…¨å±•å¼€ç‰ˆï¼Œä¾¿äºä½ å•ç‹¬çœ‹ï¼‰
å¦‚æœä½ ä¸ä½¿ç”¨ createLambdaChain() å°è£…å‡½æ•°ï¼Œä¹Ÿå¯ä»¥è¿™æ ·æ‰‹å†™æ¯ä¸ª LambdaInvokeï¼š
const step1 = new tasks.LambdaInvoke(this, 'SM1_Lambda1', {
  lambdaFunction: lambdaFn1,
  payloadResponseOnly: true, // åªä¿ç•™ Lambda è¿”å›ç»“æœé‡Œçš„ Payload å­—æ®µ
});

const step2 = new tasks.LambdaInvoke(this, 'SM1_Lambda2', {
  lambdaFunction: lambdaFn2,
  payloadResponseOnly: true,
});

const step3 = new tasks.LambdaInvoke(this, 'SM1_Lambda3', {
  lambdaFunction: lambdaFn3,
  payloadResponseOnly: true,
});

const step4 = new tasks.LambdaInvoke(this, 'SM1_Lambda4', {
  lambdaFunction: lambdaFn4,
  payloadResponseOnly: true,
});

const sm1_definition = step1.next(step2).next(step3).next(step4);

